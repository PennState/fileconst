package fileconst

import (
	"io"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	log "github.com/sirupsen/logrus"
)

type fileConstError string

func (e fileConstError) Error() string {
	return string(e)
}

const (
	NotPackageFolder fileConstError = "This should be executed in a Go package folder"
)

const fileConstTemplate = `// Code generated by fileconst DO NOT EDIT
//
// If the associated files have changed, run the following command in
// the project's root directory:
//
//   go generate ./...
//

package {{ .Package }}
{{ range .Files }}
{{ if .Comment -}}
{{ .Comment }}
{{ end -}}
const {{ .Name }} = {{ .Content }}
{{ end -}}
`

type Spec struct {
	Package string
	Files   []FileSpec
}

type FileSpec struct {
	Name    string
	Comment string
	Content string
}

func Run(dirs []string, exts map[string]bool) error {
	log.Info("Started fileconst")

	pkg, ok := os.LookupEnv("GOPACKAGE")
	if !ok {
		return NotPackageFolder
	}

	log.Infof("Go package name: %s", pkg)

	dir, err := directory()
	if err != nil {
		return err
	}

	if len(dirs) == 0 {
		dirs = append(dirs, dir)
	}

	log.Infof("Go package directory: %s", dir)

	paths, err := files(dirs)
	if err != nil {
		return err
	}

	spec, err := process(pkg, paths, exts)
	if err != nil {
		return err
	}

	log.Info("Constant files found: ", len(spec.Files))
	log.Debug("Spec: ", spec)

	out, err := os.Create(filepath.Join(dir, "fileconst_gen.go"))
	if err != nil {
		return err
	}

	log.Info("Generating \"fileconst_gen.go\" file")

	err = generate(spec, out)
	if err != nil {
		return err
	}

	log.Info("Finished fileconst")

	return nil
}

func directory() (string, error) {
	file, ok := os.LookupEnv("GOFILE")
	if !ok {
		return "", NotPackageFolder
	}

	path, err := filepath.Abs(file)
	if err != nil {
		return "", err
	}

	return filepath.Dir(path), nil
}

func files(dirs []string) ([]string, error) {
	paths := []string{}

	for _, dir := range dirs {
		fis, err := ioutil.ReadDir(dir)
		if err != nil {
			return paths, err
		}

		for _, fi := range fis {
			if fi.IsDir() {
				continue
			}

			paths = append(paths, filepath.Join(dir, fi.Name()))
		}
	}

	return paths, nil
}

func generate(spec *Spec, out io.WriteCloser) error {
	defer out.Close()

	tmplt, err := template.New("fileconst").Parse(fileConstTemplate)
	if err != nil {
		return err
	}

	err = tmplt.Execute(out, spec)
	if err != nil {
		return err
	}

	return nil
}

func process(pkg string, paths []string, exts map[string]bool) (*Spec, error) {
	spec := &Spec{
		Package: pkg,
	}

	for _, path := range paths {
		ext := path[strings.LastIndex(path, ".")+1:]
		if !exts[ext] {
			continue
		}

		data, err := ioutil.ReadFile(path)
		if err != nil {
			return spec, err
		}

		cmnt, ctnt := []string{}, []string{}

		for _, l := range strings.Split(string(data), "\n") {
			if strings.HasPrefix(l, "//") {
				cmnt = append(cmnt, l)
				continue
			}

			ctnt = append(ctnt, l)
		}

		_, name := filepath.Split(path)
		name = name[:strings.LastIndex(name, ".")]

		fspec := FileSpec{
			Name:    name,
			Comment: strings.Join(cmnt, "\n"),
			Content: "`" + strings.Join(ctnt, "\n") + "`",
		}
		spec.Files = append(spec.Files, fspec)

		log.Info("Added file to spec: ", path)
	}

	return spec, nil
}
